# smartbuf

`smartbuf`是一种新颖、高效、智能、易用的跨语言序列化框架，它既拥有不亚于`protobuf`的高性能，也拥有与`json`相仿的通用性、可扩展性、可调试性等。

与`json`、`xml`类似，`smartbuf`编码后的数据中仍然保留着`schema`信息，
无需预先协定任何数据模型，接收方即可直接完成数据的解码。这个特性赋予了`smartbuf`类似于`json`的通用、可扩展、可读性、兼容性等。

为提高数据的压缩与传输的效率，`smartbuf`内部采用**分区序列化**的策略，即将对象拆分为多个不同的分区，
针对不同的分区按照不同的规则进行紧凑的序列化，然后各个分区之间通过`id`引用并组成最终的实体对象。
关于**分区序列化**的技术细节，可以参考**分区序列化**章节。

**分区序列化**的设计策略在确保扩展性、兼容性的同时，也提供了非常高的压缩率和性能，在实际测试中它甚至比`protobuf`要更高一些。
关于**性能测试**的具体细节，可以参考**性能测试**章节。

`smartbuf`针对不同的业务场景提供两种了不同的模式`packet`与`stream`，它们分别适用于不同的实际场景，具体细节可以参考后续章节。

# 分区序列化

在`smartbuf`的设计理念中，对象由以下三部分组成：

+ `property`：组成对象的底层属性，比如整数、浮点数、字符串等
+ `struct`：描述对象实体的数据结构，包括属性名、属性列表等
+ `body`：对象实体，以引用的形式将`struct`和`property`组装为完整的实例。

针对这样的设计理念，`smartbuf`引入了**分区序列化**的概念。
即对象编码过程中，将不同的部分以独立分区的形式独立编码，从而形成若干个紧凑的分区，各个分区之间通过唯一`ID`进行关联以完成对象的组装。

## `property`分区

属性分区负责存储通用、标准的属性值，支持`const`、`float`、`double`、`varint`、`string`、`symbol`等类型，
并为这些属性值分配递增且唯一的`ID`。

在其他分区中引用这些属性的地方，直接引用`ID`即可，这个`ID`往往都很小，只需要`1~2byte`。

在实际情况下，对象树中的某些属性有可能重复出现，对于数组和集合尤其如此。此时使用`json`和`protobuf`的话，重复出现的数据会被重复序列化。
而对于`smartbuf`，得益于分区的设计，它不需要再重复序列化相同的属性，从而显著提高空间利用率。

## `struct`分区

对象在`smartbuf`编码中的表现形式类似于动态语言中的弱**类型结构体**，这一点与`json`类似。
即只负责维护松散的字段列表，而不需要考虑每个属性的具体类型，字段的真实属性取决于它的值。

`struct`分区包括两部分: `field`池与`struct`池，前者类似于`string[]`，后者类似于`int[][]`，
即结构体的表现形式为`int[]`，其中`int`表示`field`池的某个元素`ID`。

这样的设计有两个优点：

 + **字段名复用**：编码时不同对象可以复用相同的字段名，尤其是常用名称如`name`、`id`、`timestamp`、`url`等。
 + **上下文复用**：在长连接通信时，可以将整个`struct`分区缓存在上下文中重复使用，从而降低数据报文的冗余数据，提供数据传输效率。

针对这个特点，`smartbuf`内部会维护两套结构体，分别为`temporary`和`context`，
前者用于临时性地描述类似`Map`的松散对象，而后者用于描述上下文复用的`POJO`这样的固定对象，

这也是前文中提到的`packet`和`stream`两种模式的最大区别，由于不支持上下文概念，`packet`模式会把所有对象都视为`temporary`类型。

## 数据分区

数据分区事实上就等同于常规的数据体`Body`。

如上文所言，对象的`property`与`struct`都已经提取至独立的分区中，
因此在`body`中只需要通过极小的空间即可实现对`property`和`struct`的引用，从而组装成一个完整的对象。

以上规则主要针对普通`Object`，对于数组则有一套特殊的处理规则：

 + **原生数组**：原生数组作为特殊的实体，并不需要提取至`property`分区，以免`property`分区过于臃肿。
 + **数组分片**：一个数组可能包含不同的数据类型、甚至`null`，而数组分片技术就是专门设计用于这个场景

`smartbuf`对数组的处理有一套非常巧妙的算法，这个算法可以提高编码空间利用率。

## 实例演示

为加深大家对分区序列化的理解，也为了更清晰地展示`smartbuf`序列化的最终效果，本章节通过一个简单的对象演示上文所述的分区编码的细节。

以下为一个简单的`User`模型数据结构：

```proto
message User {
    int32 id = 1;
    string name = 2;
    int64 time = 3;
}
```

首次使用`smartbuf`对此模型的一个实例`User{id=1001, name="hello", time=10000L}`进行编码，其最终输出字节码结构如下所示：

![smartbuf-first-packet](./img/smartbuf-packet.png)

上图字节码中包括了对象结构元数据，所以显得臃肿了一些。

如果在`stream`模式下重复使用该模型的话，由于上下文可以缓存这些元数据，则不需要附加这些额外的描述性数据，最终编码效果如下所示：

![smartbuf-following](./img/smartbuf-stream.png)

你可以想象一下，在实际的系统开发中，我们传输的数据（尤其是数组）内部常常存在许多重复属性，
使用`smartbuf`序列化这些重复属性的话，往往只需要额外的一个字节。

除此之外，从这个例子也可以看出，即便是对于没有缓存完整上下文`schema`元数据的任何人，都可以正常解析这个报文。
当然，由于数据体中缺乏辅助性的字段信息，仍不能正常解析`id`, `name`, `time`这些字段名，只能将它们解析为无意义的序号。

这个特点对于数据可读性、可调试性都有很大的帮助，你可以通过网络抓包的方式，
直接查看`smartbuf`的编码数据报文，这一点对于`protobuf`等是很难做到的。

## 优势与劣势

分区序列化的优势与劣势都是显而易见的

# Usage

By now, `smartbuf` only support java language, you can install it by this maven dependency:

```xml
<dependency>
  <groupId>com.github.sisyphsu</groupId>
  <artifactId>smartbuf</artifactId>
  <version>0.0.1</version>
</dependency>
```

## 对比`packet`与`stream`模式

`packet`模式的序列化压缩率相对低一些，它需要为每个数据报文附加完整的元数据信息，比较适合用于类似api请求这种无上下文的场景。

`stream`模式的序列化压缩率更高，多数场景下比`protobuf`更高一些，它需要传输数据的两端保持上下文状态，比较适合用于类似长连接多路复用的场景。

## `packet`与`stream`

# 性能测试

