package com.github.smartbuf.transport;

import com.github.smartbuf.exception.InvalidVersionException;
import com.github.smartbuf.exception.MismatchModeException;
import com.github.smartbuf.exception.UnexpectedReadException;
import com.github.smartbuf.exception.UnexpectedSequenceException;
import com.github.smartbuf.node.basic.ObjectNode;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Input accepts and maintains context info that generated by {@link Output},
 * and use it to parse input object one by one.
 *
 * @author sulin
 * @since 2019-10-10 21:43:41
 */
public final class Input {

    private long sequence;

    private final boolean enableStreamMode;

    private final InputDataPool dataPool = new InputDataPool();
    private final InputMetaPool metaPool = new InputMetaPool();

    /**
     * Initialize input
     *
     * @param enableStreamMode If enable stream-mode, if not, enable packet-mode
     */
    public Input(boolean enableStreamMode) {
        this.enableStreamMode = enableStreamMode;
    }

    /**
     * Read an object from the specified InputStream
     *
     * @param inputStream The input stream to read bytes
     * @return The next object
     * @throws IOException If any io-error happens
     */
    public Object read(InputStream inputStream) throws IOException {
        InputBuffer buffer = InputBuffer.valueOf(inputStream);
        return readBuffer(buffer);
    }

    /**
     * Read the next Object from the underlying buffer.
     *
     * @param data The data to read
     * @return The next object
     * @throws IOException If any io-error happens
     */
    public Object read(byte[] data) throws IOException {
        InputBuffer buffer = InputBuffer.valueOf(data);
        return readBuffer(buffer);
    }

    /**
     * Read an object from the specified InputBuffer
     */
    Object readBuffer(InputBuffer buffer) throws IOException {
        dataPool.reset();
        metaPool.reset();

        byte head = buffer.readByte();
        boolean stream = (head & Const.VER_STREAM) != 0;
        boolean hasMeta = (head & Const.VER_HAS_META) != 0;
        boolean hasData = (head & Const.VER_HAS_DATA) != 0;
        boolean hasSeq = (head & Const.VER_HAS_SEQ) != 0;
        // valid schema
        if ((head & 0b1111_0000) != Const.VER) {
            throw new InvalidVersionException(Const.VER, head & 0b1111_0000);
        }
        if (stream != this.enableStreamMode) {
            throw new MismatchModeException(stream);
        }
        // only stream-mode needs sequence
        if (hasSeq) {
            long nextSeq = this.sequence + 1;
            long recvSeq = buffer.readByte() & 0xFF;
            if (recvSeq != (nextSeq & 0xFF)) {
                throw new UnexpectedSequenceException(nextSeq & 0xFF, recvSeq);
            }
            this.sequence = nextSeq;
        }
        // read temporary metadata
        if (hasMeta) {
            metaPool.read(buffer);
        }
        // read context metadata
        if (hasData) {
            dataPool.read(buffer);
        }
        // load data
        return readData(buffer);
    }

    /**
     * Read the next node, it could be normal data, array, or struct.
     */
    Object readData(InputBuffer buffer) throws IOException {
        long head = buffer.readVarUint();
        switch ((int) head) {
            case Const.CONST_NULL:
                return null;
            case Const.CONST_TRUE:
                return true;
            case Const.CONST_FALSE:
                return false;
            case Const.CONST_ZERO_ARRAY:
                return new Object[0];
        }
        byte flag = (byte) (head & 0b0000_0111);
        switch (flag) {
            case Const.TYPE_VARINT:
                return dataPool.getVarint((int) (head >>> 3));
            case Const.TYPE_FLOAT:
                return dataPool.getFloat((int) (head >>> 3));
            case Const.TYPE_DOUBLE:
                return dataPool.getDouble((int) (head >>> 3));
            case Const.TYPE_STRING:
                return dataPool.getString((int) (head >>> 3));
            case Const.TYPE_SYMBOL:
                return dataPool.getSymbol((int) (head >>> 3));
            case Const.TYPE_NARRAY:
                return readNativeArray(buffer, head);
            case Const.TYPE_ARRAY:
                return this.readArray(buffer, head >>> 3);
            default:
                InputMetaPool.Struct struct = metaPool.findStructByID((int) (head >>> 3));
                return this.readObject(buffer, struct);
        }
    }

    /**
     * Read an native array, like byte[] int[]
     */
    Object readNativeArray(InputBuffer buffer, long head) throws IOException {
        byte type = (byte) (head & 0b0011_1111);
        int size = (int) (head >>> 6);
        switch (type) {
            case Const.TYPE_NARRAY_BOOL:
                return buffer.readBooleanArray(size);
            case Const.TYPE_NARRAY_BYTE:
                return buffer.readByteArray(size);
            case Const.TYPE_NARRAY_SHORT:
                return buffer.readShortArray(size);
            case Const.TYPE_NARRAY_INT:
                return buffer.readIntArray(size);
            case Const.TYPE_NARRAY_LONG:
                return buffer.readLongArray(size);
            case Const.TYPE_NARRAY_FLOAT:
                return buffer.readFloatArray(size);
            case Const.TYPE_NARRAY_DOUBLE:
                return buffer.readDoubleArray(size);
            default:
                throw new UnexpectedReadException("unknown narray type");
        }
    }

    /**
     * Read an array by the specified head info
     */
    Object readArray(InputBuffer buffer, long head) throws IOException {
        List<Object[]> slices = new ArrayList<>(1);
        int totalSize = 0;
        while (true) {
            byte type = (byte) ((head >>> 1) & 0x0F);
            int size = (int) (head >>> 5);
            totalSize += size;
            Object[] slice = new Object[size];
            switch (type) {
                case Const.TYPE_SLICE_NULL:
                    break;
                case Const.TYPE_SLICE_BOOL:
                    for (int i = 0; i < size; i++) {
                        byte b = buffer.readByte();
                        switch (b) {
                            case Const.CONST_TRUE:
                                slice[i] = true;
                                break;
                            case Const.CONST_FALSE:
                                slice[i] = false;
                                break;
                            default:
                                throw new UnexpectedReadException("invalid bool[" + b + "] at offset " + i);
                        }
                    }
                    break;
                case Const.TYPE_SLICE_BYTE:
                    for (int i = 0; i < size; i++) {
                        slice[i] = buffer.readByte();
                    }
                    break;
                case Const.TYPE_SLICE_SHORT:
                    for (int i = 0; i < size; i++) {
                        slice[i] = (short) buffer.readVarInt();
                    }
                    break;
                case Const.TYPE_SLICE_INT:
                    for (int i = 0; i < size; i++) {
                        slice[i] = (int) buffer.readVarInt();
                    }
                    break;
                case Const.TYPE_SLICE_LONG:
                    for (int i = 0; i < size; i++) {
                        slice[i] = buffer.readVarInt();
                    }
                    break;
                case Const.TYPE_SLICE_FLOAT:
                    for (int i = 0; i < size; i++) {
                        slice[i] = buffer.readFloat();
                    }
                    break;
                case Const.TYPE_SLICE_DOUBLE:
                    for (int i = 0; i < size; i++) {
                        slice[i] = buffer.readDouble();
                    }
                    break;
                case Const.TYPE_SLICE_SYMBOL:
                    slice = new String[size];
                    for (int i = 0; i < size; i++) {
                        int dataId = (int) buffer.readVarUint();
                        slice[i] = enableStreamMode ? dataPool.getSymbol(dataId) : dataPool.getString(dataId);
                    }
                    break;
                case Const.TYPE_SLICE_STRING:
                    slice = new Object[size];
                    for (int i = 0; i < size; i++) {
                        slice[i] = dataPool.getString((int) buffer.readVarUint());
                    }
                    break;
                case Const.TYPE_SLICE_OBJECT:
                    slice = new Object[size];
                    int structId = (int) buffer.readVarUint();
                    InputMetaPool.Struct struct = metaPool.findStructByID(structId);
                    for (int i = 0; i < size; i++) {
                        slice[i] = this.readObject(buffer, struct);
                    }
                    break;
                case Const.TYPE_SLICE_UNKNOWN:
                    slice = new Object[size];
                    for (int i = 0; i < size; i++) {
                        slice[i] = readData(buffer);
                    }
                    break;
                default:
                    throw new UnexpectedReadException("run into invalid slice type: " + type);
            }
            slices.add(slice);
            if ((head & 1) == 0) {
                break;
            }
            head = buffer.readShort() & 0xFFFF;
        }
        if (slices.size() == 1) {
            return slices.get(0);
        }
        Object[] result = new Object[totalSize];
        int off = 0;
        for (Object[] slice : slices) {
            for (Object o : slice) {
                result[off++] = o;
            }
        }
        return result;
    }

    /**
     * Read an object by the specified fields
     */
    Object readObject(InputBuffer buffer, InputMetaPool.Struct struct) throws IOException {
        if (struct.ordered) {
            int len = struct.fieldNames.length;
            Object[] values = new Object[len];
            for (int i = 0; i < len; i++) {
                values[i] = readData(buffer);
            }
            return new ObjectNode(true, struct.fieldNames, values);
        } else {
            Map<String, Object> map = new HashMap<>();
            for (String field : struct.fieldNames) {
                map.put(field, readData(buffer));
            }
            return map;
        }
    }
}
